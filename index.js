// Janken Tournament ‚Äî Full (Pools A‚ÄìD, DM buttons, Flex with fallback, 20 players cap)
import 'dotenv/config';
import express from 'express';
import { middleware, Client } from '@line/bot-sdk';

/* ===== LINE CONFIG ===== */
const config = {
  channelSecret: process.env.LINE_CHANNEL_SECRET,
  channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN,
};
if (!config.channelSecret || !config.channelAccessToken) {
  console.error('‚ùå Missing LINE credentials'); process.exit(1);
}

const app = express();
const client = new Client(config);
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`üöÄ Server on ${PORT}`));
app.post('/webhook', middleware(config), async (req, res) => {
  try { for (const ev of (req.body?.events || [])) await handleEvent(ev); res.sendStatus(200); }
  catch (e) { console.error('Webhook error:', e?.response?.data || e?.message || e); res.sendStatus(200); }
});
app.get('/', (_req,res)=>res.send('‚úÖ Janken Tournament running'));

/* ===== STATE ===== */
const HANDS = ['rock','paper','scissors'];
const EMOJI = { rock:'‚úä', paper:'‚úã', scissors:'‚úåÔ∏è' };
const POOLS = ['A','B','C','D'];

const rooms = new Map();       // groupId -> room
const userToGroup = new Map(); // userId  -> groupId (for DM routing)

const nowTH = () => new Date().toLocaleString('th-TH', { hour12:false });
const shuffle = a => { const x=[...a]; for(let i=x.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [x[i],x[j]]=[x[j],x[i]];} return x; };
const pretty = (room,uid)=> uid ? (room.players.get(uid)?.name || '(?)') : '‚Äî Bye ‚Äî';
const judge = (a,b)=>{ if(!a||!b) return a? 'A':'B'; if(a===b) return 'DRAW'; const beats={rock:'scissors',paper:'rock',scissors:'paper'}; return beats[a]===b?'A':'B'; };
const qr = () => ({ items: HANDS.map(h=>({ type:'action', action:{ type:'message', label:h.toUpperCase(), text:h } })) });

async function safePush(to, msgs){ try{ await client.pushMessage(to, Array.isArray(msgs)?msgs:[msgs]); }catch(e){ console.warn('push fail', e?.response?.data || e?.message); } }
async function safeReply(token, msgs){ try{ await client.replyMessage(token, Array.isArray(msgs)?msgs:[msgs]); }catch(e){ console.warn('reply fail', e?.response?.data || e?.message); } }

function ensureRoom(gid){
  if (!rooms.has(gid)) {
    rooms.set(gid, {
      admin:null,
      phase:'idle',            // idle | register | playing | finished
      stage:'pools',           // pools | cross | finished
      players:new Map(),       // userId -> {name}
      bracket:{
        round:0,
        pools:{A:[],B:[],C:[],D:[]}, // per pool: [{a,b,state:'pending'|'done',moves:{},winner,loser}]
        waitingOdd:null,
        cross:[]               // for cross-bracket after pool winners
      }
    });
  }
  return rooms.get(gid);
}

/* ===== FLEX UI ===== */
function menuFlex(){
  return {
    type:'flex', altText:'Janken Menu',
    contents:{
      type:'bubble',
      header:{ type:'box', layout:'vertical', contents:[
        { type:'text', text:'üéå Janken Tournament', weight:'bold', size:'lg' }
      ]},
      body:{ type:'box', layout:'vertical', spacing:'md', contents:[
        { type:'button', style:'primary',   action:{ type:'message', label:'Join',   text:'janken join' } },
        { type:'button', style:'secondary', action:{ type:'message', label:'Close',  text:'janken close' } },
        { type:'button', style:'secondary', action:{ type:'message', label:'Status', text:'janken status' } },
        { type:'button', style:'secondary', action:{ type:'message', label:'Reset',  text:'janken reset' } },
      ]}
    }
  };
}
function openBannerFlex(){
  return {
    type:'flex', altText:'JANKEN TOURNAMENT ‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß!',
    contents:{
      type:'bubble',
      hero:{ type:'box', layout:'vertical', backgroundColor:'#111', contents:[
        { type:'text', text:'JANKEN', weight:'bold', size:'3xl', color:'#FFD54F', align:'center' },
        { type:'text', text:'TOURNAMENT', weight:'bold', size:'xl', color:'#FFFFFF', align:'center' },
        { type:'text', text:'‡πÄ‡∏õ‡∏¥‡∏î‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡πÅ‡∏•‡πâ‡∏ß!', size:'sm', color:'#BDBDBD', align:'center', margin:'sm' }
      ], paddingAll:'24px', cornerRadius:'md' },
      body:{ type:'box', layout:'vertical', spacing:'md', contents:[
        { type:'text', text:'‡πÉ‡∏Ñ‡∏£‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ä‡∏°‡∏õ‡πå‡∏™‡∏≤‡∏¢‡πÄ‡∏õ‡πà‡∏≤‡∏¢‡∏¥‡∏á‡∏â‡∏∏‡∏ö‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ô‡∏µ‡πâ?', wrap:true },
        { type:'box', layout:'vertical', backgroundColor:'#F5F5F5', cornerRadius:'md', paddingAll:'12px', contents:[
          { type:'text', text:'‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°', weight:'bold' },
          { type:'text', text:'‡∏û‡∏¥‡∏°‡∏û‡πå  janken join  ‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÅ‡∏ä‡∏ó‡∏ô‡∏µ‡πâ', size:'sm', color:'#666' },
          { type:'text', text:'‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 20 ‡∏Ñ‡∏ô ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô', size:'sm', color:'#666', margin:'sm' }
        ]}
      ]},
      footer:{ type:'box', layout:'vertical', spacing:'sm', contents:[
        { type:'button', style:'primary', color:'#FFB74D', action:{ type:'message', label:'‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏ó‡∏±‡∏ô‡∏ó‡∏µ', text:'janken join' } },
        { type:'button', style:'secondary', action:{ type:'message', label:'‡∏î‡∏π‡πÄ‡∏°‡∏ô‡∏π', text:'menu' } }
      ]}
    }
  };
}

// ‡∏™‡∏£‡∏∏‡∏õ‡∏Ñ‡∏π‡πà (‡πÅ‡∏ï‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ + fallback)
function buildFlexRoundPairs(title, lines){
  return {
    type:'flex', altText:title, contents:{
      type:'bubble',
      header:{ type:'box', layout:'vertical', contents:[
        { type:'text', text:title, weight:'bold', size:'lg' },
        { type:'text', text: nowTH(), size:'xs', color:'#999' }
      ]},
      body:{ type:'box', layout:'vertical', spacing:'sm', contents:
        lines.map(t=>({ type:'text', text:t, wrap:true }))
      }
    }
  };
}
async function tryPushFlexOrText(to, title, lines){
  const MAX = 10;
  const chunks=[]; for(let i=0;i<lines.length;i+=MAX) chunks.push(lines.slice(i,i+MAX));
  try{
    if (!chunks.length) { await safePush(to,{type:'text',text:title+'\n(‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ)'}); return; }
    for(let i=0;i<chunks.length;i++){
      const head = chunks.length>1 ? `${title} (‡∏´‡∏ô‡πâ‡∏≤ ${i+1}/${chunks.length})` : title;
      await client.pushMessage(to, [buildFlexRoundPairs(head, chunks[i])]);
    }
  }catch(e){
    await safePush(to, { type:'text', text:[title, ...lines].join('\n') });
  }
}

// Flex ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏±‡∏î‡πÉ‡∏ô DM (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏≠‡∏á)
function choiceFlex(title='‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏±‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì'){
  return {
    type:'flex',
    altText:title,
    contents:{
      type:'bubble',
      header:{ type:'box', layout:'vertical', contents:[ { type:'text', text:title, weight:'bold', size:'lg' } ] },
      body:{ type:'box', layout:'vertical', spacing:'md', contents:[
        { type:'button', style:'primary', action:{ type:'message', label:'‚úä ROCK',     text:'rock' } },
        { type:'button', style:'primary', action:{ type:'message', label:'‚úã PAPER',    text:'paper' } },
        { type:'button', style:'primary', action:{ type:'message', label:'‚úåÔ∏è SCISSORS', text:'scissors' } },
      ]},
      footer:{ type:'box', layout:'vertical', contents:[
        { type:'text', text:'(‡πÅ‡∏ï‡∏∞‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏±‡∏î‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢)', size:'xs', color:'#999' }
      ]}
    }
  };
}

/* ===== SEEDING / ANNOUNCE ===== */
const toPairs = ids => { const out=[]; for(let i=0;i<ids.length;i+=2) out.push([ids[i]||null, ids[i+1]||null]); return out; };
function seedPoolsFrom(ids){
  const pools={A:[],B:[],C:[],D:[]}, shuffled=shuffle(ids); let i=0;
  for(const id of shuffled){ pools[POOLS[i%4]].push(id); i++; }
  for (const k of POOLS) pools[k] = toPairs(pools[k]).map(([a,b])=>({ a,b,state:'pending',moves:{},winner:null,loser:null }));
  return pools;
}
const allPoolsDone = pools => POOLS.every(k => pools[k].every(m => m.state==='done'));
const poolWinners = pools => POOLS.reduce((acc,k)=> (acc[k] = pools[k].map(m=>m.winner).filter(Boolean), acc), {});

async function announcePoolsRound(gid, room, title){
  const lines=[];
  for (const k of POOLS) {
    if (!room.bracket.pools[k].length) continue;
    lines.push(`‡∏™‡∏≤‡∏¢ ${k}`);
    room.bracket.pools[k].forEach((m,i)=> lines.push(`  Match ${i+1}: ${pretty(room,m.a)} vs ${pretty(room,m.b)}`));
  }
  await tryPushFlexOrText(gid, title, lines);

  // DM ‡∏Ç‡∏≠‡∏´‡∏°‡∏±‡∏î‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÅ‡∏°‡∏ï‡∏ä‡πå (‡∏ó‡∏±‡πâ‡∏á Quick Reply ‡πÅ‡∏•‡∏∞ Flex ‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏ç‡πà)
  for (const k of POOLS) for (const m of room.bracket.pools[k]) for (const uid of [m.a,m.b]) if (uid) {
    userToGroup.set(uid, gid);
    await safePush(uid, [
      { type:'text', text:`üìù ‡∏£‡∏≠‡∏ö‡∏™‡∏≤‡∏¢ ${k} ‚Äî ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏±‡∏î (rock/paper/scissors)`, quickReply: qr() },
      choiceFlex('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏±‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ')
    ]);
  }
}

async function announceCrossRound(gid, room, title){
  const lines = room.bracket.cross.map((m,i)=>`Match ${i+1}: ${pretty(room,m.a)} vs ${pretty(room,m.b)}`);
  await tryPushFlexOrText(gid, title, lines);
  for (const m of room.bracket.cross) for (const uid of [m.a,m.b]) if (uid){
    userToGroup.set(uid, gid);
    await safePush(uid, [
      { type:'text', text:`üìù ${title} ‚Äî ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏±‡∏î`, quickReply: qr() },
      choiceFlex('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏±‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ')
    ]);
  }
}

/* ===== EVENT HANDLER ===== */
async function handleEvent(e){
  // ---------- DM: ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏±‡∏î ----------
  if (e.type==='message' && e.message.type==='text' && e.source.type==='user') {
    const choice = (e.message.text||'').trim().toLowerCase();
    if (!HANDS.includes(choice)) {
      await safeReply(e.replyToken, [
        {type:'text', text:'‡πÅ‡∏ï‡∏∞‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏û‡∏¥‡∏°‡∏û‡πå: rock / paper / scissors', quickReply: qr()},
        choiceFlex('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏±‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì')
      ]);
      return;
    }

    const gid = userToGroup.get(e.source.userId);
    if (!gid || !rooms.has(gid)) { await safeReply(e.replyToken, {type:'text', text:'‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÅ‡∏°‡∏ï‡∏ä‡πå‡∏£‡∏≠‡∏≠‡∏¢‡∏π‡πà'}); return; }
    const room = rooms.get(gid);

    // ‡∏™‡∏∏‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏°‡πÄ‡∏ä‡∏¢ 1/5 ‡πÅ‡∏ö‡∏ö
    const pick = [
      (hand)=>`‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°! ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏µ‡∏¢‡∏ö‡∏°‡∏≤‡∏Å ${hand}  ‡∏£‡∏≠‡∏Ñ‡∏π‡πà‡πÅ‡∏Ç‡πà‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏∏‡πâ‡∏ô‡∏ú‡∏•‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢!`,
      (hand)=>`‡πÄ‡∏ó‡πà‡∏°‡∏≤‡∏Å! ${hand} ‡∏Ñ‡∏∑‡∏≠‡∏´‡∏°‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏™‡∏∏‡∏î‡πÜ üòé  ‡πÄ‡∏î‡∏µ‡πã‡∏¢‡∏ß‡∏î‡∏π‡∏ú‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ô‡∏∞!`,
      (hand)=>`‡πÇ‡∏≠‡πâ‡πÇ‡∏´! ${hand} ‡∏ô‡∏µ‡πà‡∏•‡πà‡∏∞‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏ô‡∏≤‡∏¢ üí•  ‡∏£‡∏≠‡∏Ñ‡∏π‡πà‡∏ï‡πà‡∏≠‡∏™‡∏π‡πâ‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏õ‡∏°‡∏±‡∏ô‡∏™‡πå‡∏Å‡∏±‡∏ô‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°!`,
      (hand)=>`‡∏à‡∏±‡∏î‡∏°‡∏≤‡πÄ‡∏ô‡∏µ‡∏¢‡∏ô‡πÜ ${hand}  ‡∏Ç‡∏≠‡∏î‡∏π‡∏´‡∏ô‡πà‡∏≠‡∏¢‡∏™‡∏¥‡∏ß‡πà‡∏≤‡πÉ‡∏Ñ‡∏£‡∏à‡∏∞‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏Å‡∏ß‡πà‡∏≤ ‡∏£‡∏≠‡∏•‡∏∏‡πâ‡∏ô‡∏ú‡∏•‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°!`,
      (hand)=>`‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏î‡∏µ‡∏ô‡∏µ‡πà! ${hand}  ‡∏™‡∏π‡∏î‡∏´‡∏≤‡∏¢‡πÉ‡∏à‡∏•‡∏∂‡∏Å‡πÜ ‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏õ‡∏•‡∏∏‡πâ‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏¢!`
    ];
    const handLabel = `${choice.toUpperCase()} ${EMOJI[choice]}`;
    await safeReply(e.replyToken, { type:'text', text: pick[Math.floor(Math.random()*pick.length)](handLabel) });

    // ‡∏´‡∏≤ match ‡∏ó‡∏µ‡πà user ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡∏∞‡∏¢‡∏±‡∏á pending
    let found=null, poolKey=null, idx=-1;

    if (room.stage==='pools'){
      for (const k of POOLS) {
        for (let i=0;i<room.bracket.pools[k].length;i++){
          const m = room.bracket.pools[k][i];
          if (m.state!=='pending') continue;
          if (m.a===e.source.userId || m.b===e.source.userId) { found=m; poolKey=k; idx=i; break; }
        }
        if (found) break;
      }
      if (found){
        found.moves[e.source.userId] = choice;
        await tryCloseMatch_Pool(gid, room, poolKey, idx);
      }
      return;
    }

    if (room.stage==='cross'){
      for (let i=0;i<room.bracket.cross.length;i++){
        const m = room.bracket.cross[i];
        if (m.state!=='pending') continue;
        if (m.a===e.source.userId || m.b===e.source.userId) { found=m; idx=i; break; }
      }
      if (found){
        found.moves[e.source.userId] = choice;
        await tryCloseMatch_Cross(gid, room, idx);
      }
      return;
    }
    return;
  }

  // ---------- GROUP COMMAND ----------
  if (e.type!=='message' || e.message.type!=='text') return;
  if (e.source.type!=='group' && e.source.type!=='supergroup') return;

  const gid = e.source.groupId;
  const text = (e.message.text||'').trim();
  const [cmd, sub, ...rest] = text.split(/\s+/);
  const c0 = (cmd||'').toLowerCase();

  if (c0==='menu'){ await safeReply(e.replyToken, menuFlex()); return; }
  if (c0!=='janken' && c0!=='rps') return;

  const action = (sub||'').toLowerCase();
  const room = ensureRoom(gid);

  // ‡πÄ‡∏≠‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏ß‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠ default
  let displayName = 'Player';
  try { const prof = await client.getGroupMemberProfile(gid, e.source.userId); if (prof?.displayName) displayName = prof.displayName; } catch {}

  switch(action){
    case 'open': {
      room.admin  = room.admin || e.source.userId;
      room.phase  = 'register';
      room.stage  = 'pools';
      room.players = new Map();
      room.bracket = { round:0, pools:{A:[],B:[],C:[],D:[]}, waitingOdd:null, cross:[] };

      const announce = [
        'üéå‚ú®  JANKEN TOURNAMENT ‡πÄ‡∏õ‡∏¥‡∏î‡∏â‡∏≤‡∏Å‡πÅ‡∏•‡πâ‡∏ß!! ‚ú®üéå',
        '',
        '‡πÉ‡∏Ñ‡∏£‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ä‡∏°‡∏õ‡πå‡∏™‡∏≤‡∏¢‡πÄ‡∏õ‡πà‡∏≤‡∏¢‡∏¥‡∏á‡∏â‡∏∏‡∏ö‡πÅ‡∏´‡πà‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ô‡∏µ‡πâ üèÜ',
        '',
        '‡∏û‡∏¥‡∏°‡∏û‡πå  üëâ  janken join  ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏≤‡∏£‡πÅ‡∏Ç‡πà‡∏á‡∏Ç‡∏±‡∏ô',
        '‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 20 ‡∏Ñ‡∏ô ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‚ÄºÔ∏è',
        '',
        '‚è≥ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß ‡∏ú‡∏π‡πâ‡∏à‡∏±‡∏î‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏û‡∏¥‡∏°‡∏û‡πå  "janken close"  ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÅ‡∏Ç‡πà‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢!'
      ].join('\n');

      await safePush(gid, { type:'text', text: announce });
      await safePush(gid, openBannerFlex());
      await safeReply(e.replyToken, [ menuFlex(), { type:'text', text:'üü¢ ‡πÄ‡∏õ‡∏¥‡∏î‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡πÅ‡∏•‡πâ‡∏ß (‡∏û‡∏¥‡∏°‡∏û‡πå janken join ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°)' } ]);
      break;
    }

    case 'join': {
      if (room.phase!=='register') { await safeReply(e.replyToken, {type:'text', text:'‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏¥‡∏î‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏±‡∏Ñ‡∏£'}); break; }
      const MAX_PLAYERS = 20;
      if (room.players.size >= MAX_PLAYERS) { await safeReply(e.replyToken, {type:'text', text:`‚ùå ‡∏ó‡∏±‡∏ß‡∏£‡πå‡∏ô‡∏≤‡πÄ‡∏°‡∏ô‡∏ï‡πå‡πÄ‡∏ï‡πá‡∏°‡πÅ‡∏•‡πâ‡∏ß (${MAX_PLAYERS} ‡∏Ñ‡∏ô)`}); break; }
      const name = (rest.join(' ') || displayName).slice(0,40);
      room.players.set(e.source.userId, { name });
      userToGroup.set(e.source.userId, gid);
      await safeReply(e.replyToken, { type:'text', text:`‚úÖ ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡πÅ‡∏•‡πâ‡∏ß: ${name} (‡∏£‡∏ß‡∏° ${room.players.size}/${MAX_PLAYERS})` });
      break;
    }

    case 'close': {
      if (room.phase!=='register') { await safeReply(e.replyToken, {type:'text', text:'‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡∏¥‡∏î‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏±‡∏Ñ‡∏£'}); break; }
      if (room.players.size < 2)   { await safeReply(e.replyToken, {type:'text', text:'‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 ‡∏Ñ‡∏ô'}); break; }

      const ids = [...room.players.keys()];
      if (ids.length % 2 === 1) room.bracket.waitingOdd = ids.pop(); // ‡∏Å‡∏±‡∏ô‡πÄ‡∏•‡∏Ç‡∏Ñ‡∏µ‡πà‡πÑ‡∏ß‡πâ 1 ‡∏Ñ‡∏ô
      room.bracket.pools = seedPoolsFrom(ids);
      room.bracket.round = 1;
      room.phase='playing';
      room.stage='pools';

      // ‡∏™‡πà‡∏á‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤‡∏Å‡πà‡∏≠‡∏ô (‡∏Å‡∏±‡∏ô Flex ‡∏•‡πâ‡∏°‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏á‡∏µ‡∏¢‡∏ö)
      await safePush(gid, { type:'text', text:`üì£ Match ${room.bracket.round} ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß (‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô ${room.players.size})` });

      await announcePoolsRound(gid, room, `üì£ Match ${room.bracket.round} ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß (‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô ${room.players.size})`);

      // ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡πâ‡∏≤‡∏¢‡∏™‡∏£‡∏∏‡∏õ (‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ç‡∏≠)
      await safePush(gid, { type:'text', text:'üì© ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏ä‡πá‡∏Ñ‡πÑ‡∏•‡∏ô‡πå‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏±‡∏î‡∏î‡∏ß‡∏•‡∏Å‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ï‡πà‡∏≠‡∏™‡∏π‡πâ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì' });
      break;
    }

    case 'status': {
      const head = room.phase==='register' ? `üìù ‡πÄ‡∏õ‡∏¥‡∏î‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏≠‡∏¢‡∏π‡πà: ${room.players.size} ‡∏Ñ‡∏ô`
                : room.phase==='playing'  ? `üéÆ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏Ç‡πà‡∏á ‚Äî ‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà ${room.bracket.round} [${room.stage}]`
                : room.phase==='finished' ? `üèÅ ‡∏à‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏Ç‡πà‡∏á‡∏Ç‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß` : '‚Äî';
      await safeReply(e.replyToken, { type:'text', text: head });
      break;
    }

    case 'reset': {
      rooms.delete(gid);
      await safeReply(e.replyToken, { type:'text', text:'‚ôªÔ∏è ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÅ‡∏•‡πâ‡∏ß ‚Äî janken open ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà' });
      break;
    }

    default: {
      await safeReply(e.replyToken, menuFlex());
    }
  }
}

/* ===== MATCH RESOLUTION ===== */
async function tryCloseMatch_Pool(gid, room, k, idx){
  const m = room.bracket.pools[k][idx];
  const aH = m.moves[m.a], bH = m.moves[m.b];

  // BYE
  if (m.a && !m.b) { m.winner=m.a; m.loser=null; m.state='done'; await safePush(gid, { type:'text', text:`‚úÖ ‡∏™‡∏≤‡∏¢ ${k} ‚Äî Match ${idx+1}: ${pretty(room,m.a)} ‡πÑ‡∏î‡πâ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏ö‡∏≤‡∏¢` }); }
  else if (m.b && !m.a) { m.winner=m.b; m.loser=null; m.state='done'; await safePush(gid, { type:'text', text:`‚úÖ ‡∏™‡∏≤‡∏¢ ${k} ‚Äî Match ${idx+1}: ${pretty(room,m.b)} ‡πÑ‡∏î‡πâ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏ö‡∏≤‡∏¢` }); }
  else if (aH && bH){
    const r = judge(aH,bH);
    if (r==='DRAW'){
      m.moves={};
      for (const uid of [m.a,m.b]) if (uid) await safePush(uid, [
        {type:'text', text:'‡πÄ‡∏™‡∏°‡∏≠ ‚Äî ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏´‡∏°‡πà', quickReply: qr()},
        choiceFlex('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á')
      ]);
      return;
    }
    m.winner = r==='A'? m.a : m.b; m.loser = r==='A'? m.b : m.a; m.state='done';
    // ‡∏™‡πà‡∏á‡∏ú‡∏•‡πÄ‡∏õ‡πá‡∏ô Flex (fallback ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)
    try{
      await client.pushMessage(gid, [ flexMatchResult(`‡∏™‡∏≤‡∏¢ ${k} ‚Äî Match ${idx+1}`, pretty(room,m.a), aH, pretty(room,m.b), bH, pretty(room,m.winner)) ]);
    }catch{
      await safePush(gid, { type:'text', text:`‡∏™‡∏≤‡∏¢ ${k} ‚Äî Match ${idx+1}\n${pretty(room,m.a)} ${EMOJI[aH]} vs ${pretty(room,m.b)} ${EMOJI[bH]}\n‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞: ${pretty(room,m.winner)}` });
    }
  } else return;

  // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏π‡πà‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏™‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á "‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ" ‚Üí ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≠‡∏ö‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
  if (!allPoolsDone(room.bracket.pools)) return;

  // ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏£‡∏≠‡∏ö
  const winners = poolWinners(room.bracket.pools);
  const lines=[]; for (const kk of POOLS) if (winners[kk].length) lines.push(`‡∏™‡∏≤‡∏¢ ${kk}: ${winners[kk].map(u=>pretty(room,u)).join(', ')}`);
  await tryPushFlexOrText(gid, '‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ', lines);

  // ‡∏£‡∏≠‡∏ö‡πÅ‡∏£‡∏Å‡πÄ‡∏•‡∏Ç‡∏Ñ‡∏µ‡πà ‚Üí ‡πÉ‡∏™‡πà play-in ‡πÉ‡∏´‡πâ‡∏û‡∏ö‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡∏Ñ‡∏ô‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÅ‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏°
  if (room.bracket.round===1 && room.bracket.waitingOdd){
    const flat = Object.values(winners).flat();
    if (flat.length){
      const picked = flat[Math.floor(Math.random()*flat.length)];
      // ‡πÉ‡∏™‡πà‡πÅ‡∏°‡∏ï‡∏ä‡πå play-in ‡πÑ‡∏ß‡πâ‡πÉ‡∏ô‡∏™‡∏≤‡∏¢ A ‡∏ï‡πâ‡∏ô‡∏•‡∏¥‡∏™‡∏ï‡πå
      room.bracket.pools = {A:[{a:room.bracket.waitingOdd,b:picked,state:'pending',moves:{},winner:null,loser:null}],B:[],C:[],D:[]};
      room.bracket.waitingOdd = null;
      room.bracket.round += 1;
      await announcePoolsRound(gid, room, `üì£ ‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà ${room.bracket.round}`);
      return;
    }
  }

  // ‡∏î‡∏π‡∏ß‡πà‡∏≤‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏™‡∏≤‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÅ‡∏ä‡∏°‡∏õ‡πå‡∏™‡∏≤‡∏¢‡∏•‡∏∞ 1 ‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
  const eachPoolSingle = POOLS.every(kk => winners[kk].length<=1);
  if (!eachPoolSingle){
    // ‡∏¢‡∏±‡∏á‡∏ï‡πà‡∏≠‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏™‡∏≤‡∏¢
    const next={A:[],B:[],C:[],D:[]};
    for (const kk of POOLS){
      const ws = winners[kk];
      for (let i=0;i<ws.length;i+=2) next[kk].push({a:ws[i]||null, b:ws[i+1]||null, state:'pending', moves:{}, winner:null, loser:null});
    }
    room.bracket.pools = next;
    room.bracket.round += 1;
    await announcePoolsRound(gid, room, `üì£ ‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà ${room.bracket.round}`);
    return;
  }

  // ‡πÑ‡∏î‡πâ‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏™‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß ‚Üí cross bracket ‡∏ï‡πà‡∏≠
  const champs = Object.values(winners).flat();
  if (champs.length === 1){
    await safePush(gid, { type:'text', text:`üèÜ ‡πÅ‡∏ä‡∏°‡∏õ‡πå: ${pretty(room,champs[0])}` });
    room.phase='finished'; room.stage='finished';
    return;
  }

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á cross bracket (‡∏™‡∏∏‡πà‡∏°‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏à‡∏ô‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÅ‡∏ä‡∏°‡∏õ‡πå)
  const ids = shuffle(champs);
  const cross=[]; for (let i=0;i<ids.length;i+=2) cross.push({a:ids[i]||null, b:ids[i+1]||null, state:'pending', moves:{}, winner:null, loser:null});
  room.stage='cross';
  room.bracket.cross = cross;
  room.bracket.round += 1;
  await announceCrossRound(gid, room, 'üèÅ ‡∏£‡∏≠‡∏ö‡∏£‡∏ß‡∏° (‡∏Ç‡πâ‡∏≤‡∏°‡∏™‡∏≤‡∏¢)');
}

async function tryCloseMatch_Cross(gid, room, idx){
  const m = room.bracket.cross[idx];
  const aH = m.moves[m.a], bH = m.moves[m.b];

  if (m.a && !m.b){ m.winner=m.a; m.loser=null; m.state='done'; }
  else if (m.b && !m.a){ m.winner=m.b; m.loser=null; m.state='done'; }
  else if (aH && bH){
    const r = judge(aH,bH);
    if (r==='DRAW'){
      m.moves={};
      for (const uid of [m.a,m.b]) if (uid) await safePush(uid, [
        {type:'text', text:'‡πÄ‡∏™‡∏°‡∏≠ ‚Äî ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏´‡∏°‡πà', quickReply: qr()},
        choiceFlex('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á')
      ]);
      return;
    }
    m.winner = r==='A'? m.a : m.b; m.loser = r==='A'? m.b : m.a; m.state='done';
  } else return;

  try{
    await client.pushMessage(gid, [ flexMatchResult('‡∏ú‡∏•‡∏£‡∏≠‡∏ö‡∏£‡∏ß‡∏°', pretty(room,m.a), aH, pretty(room,m.b), bH, pretty(room,m.winner)) ]);
  }catch{
    await safePush(gid, { type:'text', text:`‡∏ú‡∏•‡∏£‡∏≠‡∏ö‡∏£‡∏ß‡∏°\n${pretty(room,m.a)} ${EMOJI[aH]||''} vs ${pretty(room,m.b)} ${EMOJI[bH]||''}\n‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞: ${pretty(room,m.winner)}` });
  }

  const done = room.bracket.cross.every(x=>x.state==='done');
  if (!done) return;

  const winners = room.bracket.cross.map(x=>x.winner).filter(Boolean);
  if (winners.length === 1){
    await safePush(gid, { type:'text', text:`üèÜ ‡πÅ‡∏ä‡∏°‡∏õ‡πå: ${pretty(room,winners[0])}` });
    room.phase='finished'; room.stage='finished';
    return;
  }
  // ‡∏à‡∏±‡∏î‡∏£‡∏≠‡∏ö‡∏ï‡πà‡∏≠‡πÉ‡∏ô cross
  const next=[]; for (let i=0;i<winners.length;i+=2) next.push({a:winners[i]||null, b:winners[i+1]||null, state:'pending', moves:{}, winner:null, loser:null});
  room.bracket.cross = next;
  room.bracket.round += 1;
  await announceCrossRound(gid, room, `üèÅ ‡∏£‡∏≠‡∏ö‡∏£‡∏ß‡∏° (‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà ${room.bracket.round})`);
}
